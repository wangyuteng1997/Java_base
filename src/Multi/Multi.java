package Multi;

/**
 * @author wang yuteng
 * @data 2020/7/23 11:08
 */
/*extends和implements都能体现继承
* 代码当中体现多态性其实就是一句话，父类引用指向子类对象
* 比如动物是父类  猫是子类  这里就是一只猫被当作动物
* 格式：
* 父类名称 对象名 = new 子类名称
* 或者：
* 接口名称 对象名 = new 实现类名称
* */
    /*如果不用多态只用子类
    * teacher one = new teacher；
    * one.work()；
    * assiatant two = new assitant；
    * two.wrok()
    * 唯一做的事情就是调用work方法，其他不担心
    *
    * 如果使用多态的方法，对比一下
    * emplyee one = new teacher；
    * emplyee two = new assistant；
    *好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化
    *
    *
    * ！！impotant
    * 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，
    * 而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，
    * 必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，
    * 从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性
    * */
public class Multi {
    public static void main(String[] args) {
        /*--------------------------------------------------------*/
//        使用多态的调用方法
        Fu obj = new Zi();
//    左侧父类的引用，指向了右侧子类的对象，看等号右边是谁，优先用谁，没有则自动向上寻找
        obj.method();

//        Fu obj = new Zi();编译看左边，运行看右边
          obj.methodfu();
          //methodfu是父类，左边编译通过，但是右边子类中没有对应的方法，就去父类中寻找    相同的方法优先使用子类的，如果子类没有去父类中去寻找
//        obj.methodZi();错误用法
//        因为obj是父类对象的，methodZi是子类中的，所以左边编译不通过
/**所以只有子类重写的时候才会看子类的方法，否则都是看父类的方法*/

/*-----------------------------------------------------------*/

//        使用多态访问成员变量的方法
/*1.直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则自动向上寻找
*2.间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上寻找
* */
        System.out.println(obj.num);
        obj.showNum();
    }
}
